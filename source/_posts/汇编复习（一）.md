---
title: 汇编复习（一）
top: false
date: 2019-03-26 17:43:41
tags: 温故知新
categories: 汇编
---
![](/uploads/assembly-languagemasm-x8086.jpg)
<!-- more -->
# 汇编
汇编语言（assembly language）是一种用于电子计算机、微处理器、微控制电路或其它可编程器件的低级语言，亦称为符号语言。在汇编语言中，用助记符（Mnemonics）代替机器指令的操作码，用地址符号（Symbol）或标号（Label）代替指令或操作数的地址。在不同的设备中，汇编语言对应着不同的机器语言指令集，通过汇编过程转换成机器指令。普遍地说，特定的汇编语言和特定的机器语言指令集是一一对应的，不同平台之间不可直接移植。

# 进制
进制即进位计算制，是人为定义的带进位的计数方法。
在早期设计的机械计算装置中，使用的还不是二进制，而是十进制或其它进制，利用齿轮的不同位置表示不同的数值，这种计算装置更加接近人类的思维方式。但是随着计算量的增加，随着电子电路的发展，二进制的优越性便逐渐凸显。使用二进制机器码，可以很方便的描述电路的各种状态，以及它们组合产生的不同逻辑门。

使用二级制的好处：
1. 技术实现简单
2. 简化运算规则
3. 适合逻辑运算
4. 易于进行转换
5. 二进制的抗干扰能力强，只有高电位和低电位两个状态。

二级制的好处大大的有，但是坏处是**书写麻烦，逢二进一的计数方案并不适合人类书写记忆。**为了克服这一障碍，于是我们有了十六进制来表示二进制。十六进制转换有16位，每一个数字位上可以是0、1、2、3、4、5、6、7、8、9、A、B、C、D、E、F，这十五个数字之一。按照进位规则，十六进制逢十六进一。

十进制转换二进制：除二取余法
![除二取余法](/uploads/chu_er_qu_yu_fa.jpg)

二进制和十六进制的相互转换：取四合一法、取一拆四法
![进制对应关系](/uploads/bin2hex.jpg)

# 比特和存储器
计算机中最小的信息单位是bit（比特，位），也就是一个二进制位。
计算机中最小的数据存储单位是Byte（B字节），8 bit = 1 byte。

- 1024B	=1KB
- 1024KB=1MB
- 1024MB=1GB
- 1024GB=1TB

存储器被划分为若干个存储单元，一个存储单元可以存储一个字节，也就是8个二进制位。
对于一个有128个存储单元的存储器：
- 容量为128字节
- 编号就是0-127

每个存储单元由两部分组成：
- 存储单元的地址（十六进制）
- 存储单元的内容（十六进制）

它们在计算机中，看起来是这样的。如下如所示，存储了
02h 1Ah ACh 00h BEh
![小端存储](/uploads/xiaoduan.jpg)
这叫**小端存储，即高位字节放在高地址，低位字节放在地地址。与之相对的还有大端，其存储规则相反。**

# 段（segment）
最常见的代码段（code segment）和数据段（data segment）。
代码段：存储程序的指令。一般可读、不可写、可执行。
数据段：存储程序中用到的数据。一般可读、可写、可执行。

8086CPU有四个段寄存器
- CS：代码段（code segment）
- DS：数据段（data segment）
- SS：栈段（stack segment）
- ES：附加（extra segment）

**8086CPU任意时刻，将CS:IP指向的内容作为即将下一步执行的指令。**
也就是说，通过改变CS:IP的值，可以改变程序的执行流程。
- 只修改IP（段内转移），比如 `jmp ax`
- 同时修改CS:IP（段间转移），比如 `jmp 3:0B13`

# 地址
计算机根据**物理地址**对代码进行定位。
```
物理地址 = 基础地址 + 偏移地址
	 = 基础地址 + 段地址x10H
```

**逻辑地址**从应用程序角度看待内存。其形式为
```
段基地址:段内偏移地址
```

将逻辑地址左移4位，加上偏移地址就得到20位物理地址。
比如：逻辑地址1234:100 -> 物理地址12400。左移四位就是一个十六进制进位。


# 标志寄存器

标志寄存器的命名，总是某F的形式（xx flag）。8086CPU的几个标志位如下。
（标志寄存器是一个整体，其中CF、OF等都是它上面的某个bit位）
- CF：进位
- PF：奇偶
- AF：辅助
- ZF：为零
- SF：符号
- TF：单步
- IF：中断
- DF：方向
- OF：溢出

状态位如CF、PF等，判断为真时等于1，否则为0。
TF、IF、DF，这些都是控制位，用于控制程序。

详解

CF（carry flag）：进位标志位，一般情况进行无符号运算时，它记录运算结果的最高位向更高位的进位值，或从更高位的借位值，如果运算结果的最高位产生了一个进位或错位，那么其值为1，否则为0。

ZF（zero flag）：零位标志位，它记录相关指令执行后的结果是否为0，如果是0，那么ZF=1，否则为0。

SF（sign flag）：符号标志位，它记录相关指令执行后的结果是否为负，如果为负，那么SF=1，否则为0。

OF（overflow flag）：溢出标志位，在进行有符号数运算的时候，如果结果超出了计算机所能表示的范围称为溢出，此时OF=1，否则为0。

以及两个用于程序控制的控制位

TF（trap flag）：追踪标志位，当追踪标志位被置为1时，CPU进入单步执行方式，即每执行一条指令产生一个单步中断请求。

IF（interrupt-enable FLAG）：中断允许标志位，用于决定CPU是否相应CPU外部的可屏蔽中断发出的中断请求，但不管该标志为何值，CPU都必须相应CPU外部的不可屏蔽中断发出的中断请求，以及CPU内部产生的中断请求。
IF=1，CPU可响应CPU外部的可屏蔽中断发出的请求，
IF=0，CPU可不响应CPU外部的可屏蔽中断发出的请求。
CPU的指令系统中也有专门的指令来改变标志位IF的值。
